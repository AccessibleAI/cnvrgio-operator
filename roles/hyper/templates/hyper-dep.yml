#jinja2: trim_blocks: "true", lstrip_blocks: "false"
apiVersion: apps/v1
kind: Deployment
metadata:
  name: "{{hyper.svcName}}"
  namespace: "{{ ansible_operator_meta.namespace }}"
  labels:
    app: "{{hyper.svcName}}"
spec:
  replicas: {{ hyper.replicas }}
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 25%
      maxSurge: 1
  selector:
    matchLabels:
      app: "{{hyper.svcName}}"
  template:
    metadata:
      labels:
        app: "{{hyper.svcName}}"
    spec:
      {% if tenancy.enabled == "true" %}
      nodeSelector:
        {{ tenancy.cnvrg.key }}: "{{ tenancy.cnvrg.value }}"
      {% endif %}
      {% if tenancy.enabled == "true" and tenancy.dedicated_nodes == "true" %}
      tolerations:
      - key: "{{ tenancy.cnvrg.key }}"
        operator: "Equal"
        value: "{{ tenancy.cnvrg.value }}"
        effect: "NoSchedule"
      {% endif %}
      containers:
        - image: "{{hyper.image}}"
          name: "{{hyper.svcName}}"
          envFrom:
            - configMapRef:
                name: env-config
          ports:
            - containerPort: {{hyper.port}}
          {% if (cnvrg_app.enableReadinessProbe | default ('true')) == "true" %}
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: "/?key={{hyper.token}}"
              port: {{hyper.port}}
              scheme: HTTP
            initialDelaySeconds: 20
            successThreshold: 1
            periodSeconds: {{ hyper.readinessPeriodSeconds | default('100') }}
            timeoutSeconds: {{ hyper.readinessTimeoutSeconds |default('60') }}
          {% endif %}
          resources:
            requests:
              cpu: "{{hyper.cpuRequest}}"
              memory: "{{hyper.memoryRequest}}"
            limits:
              cpu: "{{ hyper.cpuLimit }}"
              memory: "{{ hyper.memoryLimit }}"